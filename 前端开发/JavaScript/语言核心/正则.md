正则
---

- `()`:分组，可以捕获，即用`\1`捕获
- `(?:)`:不可以捕获的分组
- `(?=expr)`:正向先行断言，要求接下来的字符必须与expr匹配（不可捕获）
- `(?!expr)`:负向先行断言，要求接下来的字符串不与expr匹配类(不可捕获)
- `\b`：匹配单词的边界

#### 贪婪和非贪婪
正则匹配默认是贪婪的匹配，但是我们同样可以使用非贪婪的匹配，只须在待匹配的字符后跟一个问号即可`??`,`+?`,`*?`

比如，正则表达式`/a+/` 可以匹配一个或多个连续的字母a，当使用`aaa`作为匹配字符串时，会匹配三个a，但是`/a+?/`则会尽可能少的匹配，因此只会匹配第一个a，使用非贪婪模式所得到的结果也可能和期望不一致，考虑
`/a+b/`,它可以匹配一个或多个a以及一个b，当使用`aaab`作为匹配字符串时它会匹配整个字符串，当使用`/a+?b/`时，你期望能匹配一个a和最后的b，实际上却匹配了整个字符串，这是因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置，因此该匹配不考虑它的子串中更短的匹配

#### 字符串函数
- `match()`：
	- 如果是全局匹配，返回匹配到的所有匹配结果数组
	- 如果是非全局匹配，也返回数组，第一个是匹配值，后面是子表达式的值 
- `search(reg)`：
	- 如果参数不是正则，会用reg对象自动转正则
	- 返回第一个匹配字符的索引
	- 不支持全局检索
- `replace`： 
	- 支持子表达式捕获，在替换内容内使用`$1,$2` 
	- 第二个参数可以是函数,，该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身

#### 正则表达式函数
- `exec`：
	如果未匹配返回null，匹配到了返回一个数组，第一个元素是与正则表达式匹配的字符串，余下的元素是子表达式匹配的子串,属性`index`包含了发生匹配的字符位置，属性`input`是正在检索的字符串
	与`match`不同的是，不管是否是全局匹配，exec都返回一个匹配结果并且提供关于本次匹配的完整信息，当调用exec的正则含有`g`时，它把当前正则对象的`lastIndex`设置为紧挨着匹配字串的字符位置，当第二次调用时会从上次所指示的位置开始检索，如果未匹配到任何结果会将lastIndex重置为0,在任何时候你都可以手动重置正则的lastIndex，每当使用reg对象开始新的exec时，都应该将lastIndex设置为0
	
-  `test`
	调用`test`和`exec`是等价的，当`exec`返回的结果不为`null`时，`test`返回`true`，，当一个全局正则调用`test`时，如果匹配到了，同样会设置`lastIndex`
	
	`search`，`replace`，`match`并不会用到lastIndex，实际上，他们是将lastIndex置为0了，如果用一个全局的正则对多个字符串执行`test`或者`exec`，要注意要么匹配完成，要么手动置为0，不然执行检索的开始位置可能不是字符串的开始位置

	


